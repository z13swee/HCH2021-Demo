;load bitmap program

;Load the bitmap into memory at adress $1FFE, becuse the images has
;a 2 byte header, so $2000-2bytes = $1FFE
CLRSCN = $E544	; Clear Screen

VIC = $D000		       ; VIC Video Interface Chip
; SPRITEBASE_X = VIC
; SPRITEBASE_Y = VIC+1
SPRITEBASE_X = VIC
SPRITEBASE_Y = VIC+1

SPRITE_ENABLE = $D015	   ; Sprite Enable register 53269
SPRITE_EXTENDED_X = $D010
SPRITE_PTR_BASE = $47F8  ; For bank 1

; TOGGLE_BYTE = $07E8
SINE_POS = $08
ScrollerIndex = $09

*= $1000	            ;load music to $1000 and
	.binary "Overshadow_19_intro.sid", $7e

* = $52fe		; $5300 - HEADER
	.binary "zSprites.prg"

* = $5FFE		; $2000 - HEADER
  .binary "drake.kla"

* = $0801
    .word (+), 2005  ;pointer, line number
    .null $9e, ^begin;will be sys 4096
+	.word 0          ;basic line end

* = $0810

begin:

  ;byt till Bank #1, $4000-$7FFF
	lda #%11111110
	sta $DD00

  ; lda	#%00011101
  ; sta	$D018

  ; Enable sprites
  lda #$FF
	sta SPRITE_ENABLE			; Sprite Enable Register,

  ;Set sprite to use multocolor (all sprites)
  lda #$FF
  sta $D01C

	; Set background and border color
	lda	$8710
  sta	$d020
  sta	$d021

	; Ändrar inget
	; ; Extra background color #1 (only bits #0-#3).
	; lda #$0D		; $0D = Ljus grön
	; sta $d022		; Sprite extra color #1 (only bits #0-#3).

	; Ändrar inget
	; ; Extra background color #2 (only bits #0-#3).
	; lda #$0D		; $0D = Ljus grön
	; sta $d023		; Sprite extra color #1 (only bits #0-#3).

	; ; Ändrar inget
	; ; Extra background color #3 (only bits #0-#3).
	; lda #$0d		; $0D = Ljus grön
	; sta $d024		; Sprite extra color #1 (only bits #0-#3).

  ; Sprite extra color #1 (only bits #0-#3).
	lda #$04		; $0D = Ljus grön
	sta $d025		; Sprite extra color #1 (only bits #0-#3).

	; ; Ändrar inget
	; ; Sprite extra color #2 (only bits #0-#3).
	; lda #$0d		; $07 = Ljus gul
	; sta $d026		; Sprite extra color #2 (only bits #0-#3).

  ;Set color for sprite 1
	lda #$07		; $05 = Mörk grön
	sta $d027		; Sprite #1 Color (only bits #0-#3)
	sta $d028		; Set color for sprite 2
	sta $d029		; Set color for sprite 3
  sta $d02a		; Set color for sprite 4
	sta $d02b		; Set color for sprite 5
	sta $d02c		; Set color for sprite 6
	sta $d02d		; Set color for sprite 7
	sta $d02e		; Set color for sprite 8

  ; Set double width and height on srites
  lda #$FF
  sta $D01D
  sta $D017

	; Save adress in zeropage..
	lda #<SinewayeTable	; Load Last-Byte
	sta $0d

	lda #>SinewayeTable ; Load First-Byte
	sta $0e

  ; So it rolls over when first inc instruction
  lda #$FF
  sta SINE_POS

	; COPY KLA IMAGE
	jsr CLRSCN	; C64 ROM Clear Screen


	ldx	#$00			;set X-register to zero
bitmap:
	lda	$7f40,x
	sta $4400,x
	lda	$8040,x ; +100
	sta	$4500,x
	lda $8140,x
	sta	$4600,x
	lda	$8240,x ;
	sta	$4700,x
	lda	$8340,x
	sta	$4800,x

	lda	$8328,x
	sta	$d800,x
	lda	$8428,x
	sta	$d900,x
	lda	$8528,x
	sta	$da00,x
	lda	$8628,x
	sta	$db00,x

	inx					;increase x
	bne	bitmap	; if x is NOT 0, jump to loadz13logo

  ; ;Enter Bitmap mode
	lda	#$3b
	sta	$d011	; Screen control register
	lda	#$18
	sta	$d016 ; Screen control register
	lda	#$18
  sta	$d018 ; Memory setup register



  ; Set inital position for sprite
  ; ja det funkar att ha +NR för att komma till rätt adress
  ; 65pixels offset mellan spritesen
	; testar 72
  lda #00
  sta SPRITEBASE_X
  lda #72
  sta SPRITEBASE_X+2
  lda #144
  sta SPRITEBASE_X+4
  lda #216
  sta SPRITEBASE_X+6
  lda #33 ;280
  sta SPRITEBASE_X+8
  lda #105 ;
  sta SPRITEBASE_X+10
  lda #177 ;
  sta SPRITEBASE_X+12

  lda #249 ;490
  sta SPRITEBASE_X+14

  lda #100
  sta SPRITEBASE_Y
  sta SPRITEBASE_Y+2
  sta SPRITEBASE_Y+4
  sta SPRITEBASE_Y+6
  sta SPRITEBASE_Y+8
  sta SPRITEBASE_Y+10
  sta SPRITEBASE_Y+12
	lda #150
  sta SPRITEBASE_Y+14


  ; Start sprite in 'extended' position
  lda #%11110001
  sta $D010

  ; Set initial Sprite texture

  ldy ScrollerIndex
  ldx #07
SetSpriteData:
  lda Scrollertext,y

	sta $4400,x
	cmp #$20			; Blank
	bne NotSpace

	lda #2	; eh.. bytte från 6 till 2, fixade konstig sprite texture(!?)
	sta $4400,x

NotSpace:
  clc
  adc #12
  sta SPRITE_PTR_BASE,y

  iny
  dex									; sets the Z flag if X is a 0 as a result of the decrement,
	 										; otherwise it resets the Z flag.

  bne SetSpriteData		; Branch on Z = 0

	; Vet inte riktigt varför två dey behövs
	; men det löste problemet med att komma
	; i rätt position av nästa bokstav
	dey
	dey
  sty ScrollerIndex   ; Save index

; ; TEST
; 	ldy #15
; 	lda Scrollertext,y
; 	ldy #07
; 	clc
; 	adc #12
; 	sta SPRITE_PTR_BASE,y

	; Setup a raster intrerrupt
	; ----------------------------------------------------------------------------

	sei        ;disable maskable IRQs

	lda #$7f
	sta $dc0d  ;disable timer interrupts which can be generated by the two CIA chips
	sta $dd0d  ;the kernal uses such an interrupt to flash the cursor and scan the keyboard, so we better
	           ;stop it.

	lda $dc0d  ;by reading this two registers we negate any pending CIA irqs.
	lda $dd0d  ;if we don't do this, a pending CIA irq might occur after we finish setting up our irq.
	           ;we don't want that to happen.

	lda #$01   ;this is how to tell the VICII to generate a raster interrupt
	sta $d01a

	lda #$c8   ;this is how to tell at which rasterline we want the irq to be triggered
	sta $d012

	; lda #$1b   ;as there are more than 256 rasterlines, the topmost bit of $d011 serves as
	; sta $d011  ;the 9th bit for the rasterline we want our irq to be triggered.
	;            ;here we simply set up a character screen, leaving the topmost bit 0.

	lda #$35   ;we turn off the BASIC and KERNAL rom here
	sta $01    ;the cpu now sees RAM everywhere except at $d000-$e000, where still the registers of
	           ;SID/VICII/etc are visible

	lda #<irq  ;this is how we set up
	sta $fffe  ;the address of our interrupt code
	lda #>irq
	sta $ffff

	lda #$00
	jsr $1000 ;Initialize Richard's music

	cli        ;enable maskable interrupts again

	jmp *      ;we better don't RTS, the ROMS are now switched off, there's no way back to the system



irq:

	;Being all kernal irq handlers switched off we have to do more work by ourselves.
	;When an interrupt happens the CPU will stop what its doing, store the status and return address
	;into the stack, and then jump to the interrupt routine. It will not store other registers, and if
	;we destroy the value of A/X/Y in the interrupt routine, then when returning from the interrupt to
	;what the CPU was doing will lead to unpredictable results (most probably a crash). So we better
	;store those registers, and restore their original value before reentering the code the CPU was
	;interrupted running.

	;If you won't change the value of a register you are safe to not to store / restore its value.
	;However, it's easy to screw up code like that with later modifying it to use another register too
	;and forgetting about storing its state.

	;The method shown here to store the registers is the most orthodox and most failsafe.

	pha        ;store register A in stack
	txa
	pha        ;store register X in stack
	tya
	pha        ;store register Y in stack



loop:
  ; jsr delayRoutine

  ; Reset CurrentSpriteMask
  lda #$01
  sta CurrentSpriteMask

	ldy #$00
	sty Sprite_Pointer_Index

  ; Move sprites too the left, one by one
  ldx #00
MoveSprite:
  dec SPRITEBASE_X,x

  ; Check if we need to toggle extended bit
  lda SPRITEBASE_X,x
  cmp #$00						; Z flag is set on an equal comparison, reset otherwise
  bne NotZero     		; Branch on Z = 0

  ; Otherwise toggle x extended bit
  lda SPRITE_EXTENDED_X
  eor CurrentSpriteMask
  sta SPRITE_EXTENDED_X

	dec SPRITEBASE_X,x ; This is to remove flickering eadge cases

NotZero:
	; kolla här istället ifall vi behöver byta sprite data
	; kolla om är i extended, isf byt data?
	lda SPRITE_EXTENDED_X
	and CurrentSpriteMask		; sets the zero flag if the result in the accumulator is 0
	beq NoChange       			; branch on z = 0

	clc
	lda SPRITEBASE_X,x
	cmp #$A0					; Carry flag is set when the value in memory is less than or equal to the accumulator
	bne NoChange     	;

	; Byt data
  inc ScrollerIndex

  ldy ScrollerIndex
  lda Scrollertext,y    ; Get next letter

	; Ska försöka få scrollern att loopa om tidigare så
	; att man slipper vänta på att ScrollerIndex slår runt
	cpy #180
	bne nottheendofscroller

	ldy #00
	sty ScrollerIndex

nottheendofscroller:
; 	; ; Kolla efter special karaktärer
; 	; cmp #$20			; Blank
; 	; bne ContinueCharSetting
; 	;
; 	; lda #106
;
;
; ContinueCharSetting:
	ldy Sprite_Pointer_Index
  clc
  adc #12
	sta SPRITE_PTR_BASE,y

	sty Sprite_Pointer_Index

NoChange:
	clc
	rol CurrentSpriteMask
	inc Sprite_Pointer_Index
	inx
	inx
	cpx #14					; If the value in memory is equal to the value in index
									; register X, the Z flag is set
	bne MoveSprite 	; Branch on Z = 0
  ; -----------------------------------
  ; jmp loop ; dbg stop





  inc SINE_POS

  ; Set Y position for every sprite
  ldx #00
  ldy SINE_POS
plotter:

  ; Load Y values and decrease X cooardinates for sprite
	lda SinewayeTable,y
	sta SPRITEBASE_Y,x

  ; Small loop for getting diffrent y position
  lda #13
  sta TmpByte
smallloop:
  iny
  dec TmpByte
  bne smallloop

  inc SpriteIndex
  inx
  inx
  cpx #16
  bne plotter

	; jmp loop

	dec Speed
	bpl loop

	jsr $1003 ;Play the music

	; Restore speed value
	lda #$03
	sta Speed

	lda #$ff   ;this is the orthodox and safe way of clearing the interrupt condition of the VICII.
	sta $d019  ;if you don't do this the interrupt condition will be present all the time and you end
	           ;up having the CPU running the interrupt code all the time, as when it exists the
	           ;interrupt, the interrupt request from the VICII will be there again regardless of the
	           ;rasterline counter.

	           ;it's pretty safe to use inc $d019 (or any other rmw instruction) for brevity, they
	           ;will only fail on hardware like c65 or supercpu. c64dtv is ok with this though.

	pla
	tay        ;restore register Y from stack (remember stack is FIFO: First In First Out)
	pla
	tax        ;restore register X from stack
	pla        ;restore register A from stack

	rti        ;Return From Interrupt, this will load into the Program Counter register the address
	           ;where the CPU was when the interrupt condition arised which will make the CPU continue
	           ;the code it was interrupted at also restores the status register of the CPU

;-----------------------------------


delayRoutine: ; delay for sprite move
	  ldx #$02	; set prescaler outer loop
		; inc $d025 ; Flash color 2 for sprites
	y11:
	  ldy #$ff	; set prescaler inner loop

	y1:
	  dey		; y--
	  bne y1		; no reached of zero
	  dex		; x--
	  bne y11		;
	  rts

SinewayeTable
.Byte 175,174,173,172,171,170,169,168,167,166,165,164,164,163,162,161
.Byte 161,160,159,159,158,158,157,157,156,156,156,156,155,155,155,155
.Byte 155,155,155,155,155,156,156,156,157,157,157,158,158,159,160,160
.Byte 161,162,162,163,164,165,165,166,167,168,169,170,171,172,173,174
.Byte 175,176,177,178,179,179,180,181,182,183,184,185,186,186,187,188
.Byte 188,189,190,190,191,191,192,192,193,193,193,193,194,194,194,194
.Byte 194,194,194,194,194,193,193,193,192,192,192,191,190,190,189,189
.Byte 188,187,187,186,185,184,183,182,182,181,180,179,178,177,176,175
.Byte 174,173,172,171,170,169,168,167,167,166,165,164,163,162,162,161
.Byte 160,160,159,159,158,157,157,157,156,156,156,155,155,155,155,155
.Byte 155,155,155,155,156,156,156,156,157,157,158,158,159,159,160,161
.Byte 161,162,163,163,164,165,166,167,168,169,170,170,171,172,173,174
.Byte 175,176,177,178,179,180,181,182,183,184,184,185,186,187,187,188
.Byte 189,189,190,191,191,192,192,192,193,193,193,194,194,194,194,194
.Byte 194,194,194,194,193,193,193,193,192,192,191,191,190,190,189,188
.Byte 188,187,186,185,185,184,183,182,181,180,179,178,177,176,175,175

TmpByte
.Byte $00

Sprite_Pointer_Index
.Byte $00

CurrentSpriteMask
.Byte $01

SpriteIndex
.Byte $01

Speed
.Byte $04

Scrollertext:
; .text "ABCDEFGHIJKLMNQPRSTXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
; .text "ABCDEF GH IJKLMNQPRSTXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX"
; .text "HEJALLABARNNUBLIRDETBARNPROGRAM"
.text "             GREETINGS FROM HIGH COAST HACK! AND TO THE OLD FARTS MAKEING IT POSSIBLE. THANKS TO ZCHRIS MENTHOS ATTLE LUDDE! MUSIC IS STOLEN FROM: ABEL VINCZE OVERSHADOW 19 INTRO"
